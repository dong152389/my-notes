# 基本使用

## 环境准备

1. shiro 不依赖容器，直接创建 maven 工程即可。
2. 环境搭建

~~~xml
<!-- pom.xml -->
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>shiro-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <name>shiro-demo</name>
    <url>http://www.example.com</url>

    <packaging>jar</packaging>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>

            <!-- This plugin is only to test run our little application.  It is not
                 needed in most Shiro-enabled applications: -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>1.1</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>java</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <classpathScope>test</classpathScope>
                    <mainClass>Tutorial</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.10.1</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.12</version>
        </dependency>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
    </dependencies>

</project>
~~~

~~~properties
#log4j.properties
############# 日志输出到控制台 #############
# 通过根元素指定日志输出的级别、目的地
# 日志输出的优先级：  debug < info < warn < error
log4j.rootLogger=INFO,CONSOLE
# 日志输出到控制台使用的api类
log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Target = System.out
log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d %p %c.%M()-%m%n
~~~

## INI 文件 

 Shiro 获取权限相关信息可以通过数据库获取，也可以通过 ini 配置文件获取。

1、在 resource 创建 INI 文件

~~~ini
# -----------------------------------------------------------------------------
# Users and their (optional) assigned roles
# username = password, role1, role2, ..., roleN
# -----------------------------------------------------------------------------
[users]
root = root, admin
guest = guest, guest
presidentskroob = 12345, president
darkhelmet = ludicrousspeed, darklord, schwartz
lonestarr = vespa, goodguy, schwartz

# -----------------------------------------------------------------------------
# Roles with assigned permissions
# roleName = perm1, perm2, ..., permN
# -----------------------------------------------------------------------------
[roles]
admin = *
schwartz = lightsaber:*
goodguy = winnebago:drive:eagle5
~~~

## 登录认证

### 登录认证概念  

* 身份验证：一般需要提供如身份ID等一些标识信息来表明登录者的身份，如提供 email，用户名/密码来证明。
* 在shiro中，用户需要提供principals（身份）和credentials（证明）给shiro，从而应用能验证用户身份。
* principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/邮箱/手机号。
* credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。
* 最常见的principals和credentials组合就是用户名/密码。

### 登录认证基本流程

1. 收集用户身份/凭证，即如用户名/密码。
2. 调用 Subject.login 进行登录，如果失败将得到相应 的 AuthenticationException  异常，根据异常提示用户 错误信息；否则登录成功。
3. 创建自定义的 Realm 类，继承 org.apache.shiro.realm.AuthenticatingRealm 类， 实现 doGetAuthenticationInfo() 方法。

<img src="C:\Users\Fengdong.Duan\Desktop\my-notes\shiro\assets\ShiroAuthenticationSequence.png" alt="authentication flow diagram" style="zoom:150%;" />

### 登录认证实例

创建测试类，获取认证对象，进行登录认证，如下：

~~~java
public class Tutorial {
    private static final Logger log = LoggerFactory.getLogger(Tutorial.class);

    public static void main(String[] args) {
        log.info("My First Apache Shiro Application");
        Environment environment = new BasicIniEnvironment("classpath:shiro.ini");
        SecurityManager securityManager = environment.getSecurityManager();
        //这种方式Shiro已经弃用
        // Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
        // SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        //获取 Subject 对象
        Subject subject = SecurityUtils.getSubject();
        //完成登录
        if (!subject.isAuthenticated()) {
            //创建 token 对象，web 应用用户名密码从页面传递
            UsernamePasswordToken token = new UsernamePasswordToken("darkhelmet", "ludicrousspeed");
            //记住我
            token.setRememberMe(true);
            try {
                subject.login(token);
            } catch (UnknownAccountException e) {
                e.printStackTrace();
                log.error("用户不存在！");
                System.out.println("用户不存在");
            } catch (IncorrectCredentialsException e) {
                e.printStackTrace();
                log.error("密码错误！");
            } catch (AuthenticationException ae) {
                //unexpected condition? error?
            }
        }
    }
}
~~~

### 身份认证流程

1. 首先调用 **Subject.login(token)** 进行登录，其会自动委托给 **SecurityManager**。
2. SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证。
3. Authenticator 才是真正的身份验证者，Shiro API 中核心的身份 认证入口点，此 处可以自定义插入自己的实现。
4. Authenticator 可能会委托给相应的 AuthenticationStrategy 进 行多 Realm 身份 验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm  身份验证。
5. Authenticator 会把相应的 token 传入 Realm，从 Realm 获取 身份验证信息，如 果没有返回/抛出异常表示身份验证失败了。此处 可以配置多个Realm，将按照相应的顺序 及策略进行访问。

## 角色、授权

### 授权概念

* **授权：**也叫<font color="red">访问控制，即在应用中控制谁访问哪些资源</font>（如访问页面 / 编辑数据 / 页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权 限 （Permission）、角色（Role）。
* **主体(Subject)：**访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。
* **资源(Resource)**：在应用中用户可以访问的 URL，比如访问 JSP 页面、查看/编辑 某些 数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。 （4）权限(Permission)：安全策略中的原子授权单位，通过权限我们可以表示在应用中 用户 有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访 问用 户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权 限控 制）等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允 不允 许。 （5）Shiro 支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权 限， 即实例级别的） （6）角色(Role)：权限的集合，一般情况下会赋予用户角色而不是权限，即这样用户可 以拥有 一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工 程师等 都是角色，不同的角色拥有一组不同的权限 